#include "ObjectPropertiesWidget.hpp"
#include "ui_ObjectProperties.h" // The header generated from your .ui file

#include "Scene.hpp"
#include "components.hpp"
#include "QtHelpers.hpp" // Your helper functions for setting up widgets

#include <QSignalBlocker>
#include <QColorDialog>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtx/euler_angles.hpp>

// Use the Ui namespace generated by Qt Designer
namespace Ui {
    // This is the actual class name inside the generated header
    class ObjectProperties : public Ui_Form {};
}

ObjectPropertiesWidget::ObjectPropertiesWidget(Scene* scene, QWidget* parent)
    : QWidget(parent),
    ui(new Ui::Form), // Use Ui::Form as defined in the autogen file
    m_scene(scene),
    m_currentEntity(entt::null),
    m_isUpdatingUI(false)
{
    ui->setupUi(this);    // Set up the UI defined in ObjectProperties.ui onto this widget
    initializeUI();       // Apply custom ranges, steps, and initial states
    setupConnections();   // Connect all signals from UI widgets to their corresponding slots

    setEntity(entt::null); // Initialize the panel to a blank/disabled state
}

ObjectPropertiesWidget::~ObjectPropertiesWidget()
{
    delete ui; // Clean up the UI pointer
}

// --- IMenu Interface Stubs ---

void ObjectPropertiesWidget::initializeFresh()
{
    // On a fresh start, ensure no entity is selected and the UI is clear.
    setEntity(entt::null);
}

void ObjectPropertiesWidget::initializeFromDatabase()
{
    // For now, just do a fresh initialization.
    // Later, you could load the last selected entity's ID from the database if desired.
    initializeFresh();
}

void ObjectPropertiesWidget::shutdownAndSave()
{
    // This is where you would save the state of this panel to the database if needed.
    // For an object properties panel, there's often nothing to save, as its state
    // is just a reflection of the selected object in the scene.
}

// --- Initialization ---

void ObjectPropertiesWidget::initializeUI()
{
    // Use your QtHelpers to configure spin boxes for a better user experience.
    // This makes the code cleaner and more consistent.
    WH::unbounded(ui->XPositionDoubleSpinBox);
    WH::unbounded(ui->YPositionDoubleSpinBox);
    WH::unbounded(ui->ZPositionDoubleSpinBox);
    WH::unbounded(ui->XScaleDoubleSpinBox, 3, 0.1);
    WH::unbounded(ui->YScaleDoubleSpinBox, 3, 0.1);
    WH::unbounded(ui->ZScaleDoubleSpinBox, 3, 0.1);

    WH::range180deg(ui->PitchdoubleSpinBox);
    WH::range180deg(ui->YawdoubleSpinBox);
    WH::range180deg(ui->RolldoubleSpinBox);

    WH::unbounded(ui->QuatWdoubleSpinBox, 5);
    WH::unbounded(ui->QuatXdoubleSpinBox, 5);
    WH::unbounded(ui->QuatYdoubleSpinBox, 5);
    WH::unbounded(ui->QuatZdoubleSpinBox, 5);

    // Set initial state for stacked widgets
    ui->stackedWidget->setCurrentWidget(ui->eulerRotationStackPage);
}

void ObjectPropertiesWidget::setupConnections()
{
    // When an item in the scene outliner is clicked, update the entire panel.
    connect(ui->sceneTreeWidget, &QTreeWidget::currentItemChanged, this, &ObjectPropertiesWidget::onSceneSelectionChanged);

    // --- Object Tab ---
    connect(ui->objectNameInputField, &QLineEdit::textChanged, this, &ObjectPropertiesWidget::onNameChanged);
    connect(ui->rotationTypeSelectionSpinBox, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &ObjectPropertiesWidget::onRotationTypeChanged);

    // Connect all transform spin boxes to the same slot for efficiency
    connect(ui->XPositionDoubleSpinBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onTransformChanged);
    connect(ui->YPositionDoubleSpinBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onTransformChanged);
    connect(ui->ZPositionDoubleSpinBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onTransformChanged);
    connect(ui->PitchdoubleSpinBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onTransformChanged);
    connect(ui->YawdoubleSpinBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onTransformChanged);
    connect(ui->RolldoubleSpinBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onTransformChanged);
    connect(ui->QuatWdoubleSpinBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onTransformChanged);
    connect(ui->QuatXdoubleSpinBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onTransformChanged);
    connect(ui->QuatYdoubleSpinBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onTransformChanged);
    connect(ui->QuatZdoubleSpinBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onTransformChanged);
    connect(ui->XScaleDoubleSpinBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onTransformChanged);
    connect(ui->YScaleDoubleSpinBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onTransformChanged);
    connect(ui->ZScaleDoubleSpinBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onTransformChanged);

    // --- Physics Tab ---
    connect(ui->bodyTypeInputComboBox, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &ObjectPropertiesWidget::onRigidBodyPropertyChanged);
    connect(ui->MassInputDSBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onRigidBodyPropertyChanged);
    connect(ui->DensityInputDSBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onRigidBodyPropertyChanged);
    connect(ui->LinearDampingInputDSBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onRigidBodyPropertyChanged);
    connect(ui->AngularDampingInputDSBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onRigidBodyPropertyChanged);

    connect(ui->SoftBodyPhysicsEnableCheckbox, &QCheckBox::toggled, this, &ObjectPropertiesWidget::onSoftBodyToggled);
    connect(ui->MaterialDampingInputDSBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onSoftBodyPropertyChanged);
    connect(ui->PressureInputDSBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onSoftBodyPropertyChanged);
    connect(ui->IntegrationTimestepInputDSBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onSoftBodyPropertyChanged);
    connect(ui->ConstraintIterationsInputSpinBox, &QSpinBox::valueChanged, this, &ObjectPropertiesWidget::onSoftBodyPropertyChanged);

    // --- Material Tab ---
    connect(ui->MaterialTreeBrowser, &QTreeWidget::itemDoubleClicked, this, &ObjectPropertiesWidget::onMaterialSelectionChanged);

    // Physical Properties
    connect(ui->YoungsModulusInputDSBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onPhysicalPropertiesChanged);
    connect(ui->PoissonInputDSBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onPhysicalPropertiesChanged);
    connect(ui->DensityInputDSBox_2, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onPhysicalPropertiesChanged);
    connect(ui->YieldStrengthInputDSBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onPhysicalPropertiesChanged);
    connect(ui->UTSInputDSBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onPhysicalPropertiesChanged);
    connect(ui->FatigueLimitInputDSBox, &QDoubleSpinBox::valueChanged, this, &ObjectPropertiesWidget::onPhysicalPropertiesChanged);

    // Appearance Properties
    connect(ui->albedoColorPickerButton, &QToolButton::clicked, this, &ObjectPropertiesWidget::onAlbedoColorPickerClicked);
    connect(ui->EmissiveColorPickerButton, &QToolButton::clicked, this, &ObjectPropertiesWidget::onEmissiveColorPickerClicked);
    connect(ui->dispalcementTypeComboBox, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &ObjectPropertiesWidget::onDisplacementTypeChanged);

    // Connect all sliders and spinboxes for appearance
    // This is verbose but ensures any change triggers an update.
    // A more advanced approach might use a QSignalMapper.
    auto connectAppearanceWidgets = [&](auto* widget) {
        connect(widget, &std::decay_t<decltype(*widget)>::valueChanged, this, &ObjectPropertiesWidget::onAppearancePropertiesChanged);
        };
    connectAppearanceWidgets(ui->albedoRInputDSBox);
    connectAppearanceWidgets(ui->albedoGInputDSBox);
    connectAppearanceWidgets(ui->albedoBInputDSBox);
    connectAppearanceWidgets(ui->textureTilingUInputDSBox);
    connectAppearanceWidgets(ui->textureTilingVInputDSBox);
    connectAppearanceWidgets(ui->opacityStrengthSlider);
    connectAppearanceWidgets(ui->metallicStrengthSlider);
    connectAppearanceWidgets(ui->roughnessStrengthSlider);
    connectAppearanceWidgets(ui->aoStrengthSlider);
    connectAppearanceWidgets(ui->normalStrengthSlider);
    connectAppearanceWidgets(ui->heightStrengthSlider);
    connectAppearanceWidgets(ui->POMStepInputDSBox);
    connectAppearanceWidgets(ui->emissiveRInputDSBox);
    connectAppearanceWidgets(ui->emissiveGInputDSBox);
    connectAppearanceWidgets(ui->emissiveBInputDSBox);
    connectAppearanceWidgets(ui->emissiveStrengthSlider);
}


// --- Public Slots ---

void ObjectPropertiesWidget::setEntity(entt::entity entity)
{
    m_currentEntity = entity;
    populateAllTabs();
}


// --- Private Slots ---

void ObjectPropertiesWidget::onSceneSelectionChanged()
{
    // This slot is connected to the scene outliner's selection change signal.
    // For now, we assume you will call setEntity() directly.
    // If you connect a signal to this, you would get the entity from the QTreeWidgetItem
    // and then call setEntity().
}

void ObjectPropertiesWidget::onNameChanged(const QString& newName)
{
    if (m_isUpdatingUI) return;
    if (m_scene->getRegistry().valid(m_currentEntity))
    {
        auto& tag = m_scene->getRegistry().get_or_emplace<TagComponent>(m_currentEntity);
        tag.tag = newName.toStdString();
    }
}

void ObjectPropertiesWidget::onTransformChanged()
{
    if (m_isUpdatingUI) return;
    updateTransformComponent();
}

void ObjectPropertiesWidget::onRotationTypeChanged(int index)
{
    if (m_isUpdatingUI) return;
    ui->stackedWidget->setCurrentIndex(index);
    // When switching, re-read the component to ensure the displayed values are correct
    if (m_scene->getRegistry().valid(m_currentEntity)) {
        if (auto* transform = m_scene->getRegistry().try_get<TransformComponent>(m_currentEntity)) {
            const QSignalBlocker blocker(this);
            m_isUpdatingUI = true;
            // Re-populate the transform inputs to sync both Euler and Quat fields
            updateTransformInputs(*transform);
            m_isUpdatingUI = false;
        }
    }
}

void ObjectPropertiesWidget::onRigidBodyPropertyChanged()
{
    if (m_isUpdatingUI) return;
    updateRigidBodyComponent();
}

void ObjectPropertiesWidget::onSoftBodyToggled(bool checked)
{
    if (m_isUpdatingUI) return;
    ui->groupBox_7->setEnabled(checked); // FEM Properties
    ui->groupBox_11->setEnabled(checked); // Solver Settings

    if (m_scene->getRegistry().valid(m_currentEntity)) {
        if (checked) {
            m_scene->getRegistry().get_or_emplace<SoftBodyComponent>(m_currentEntity);
        }
        else {
            m_scene->getRegistry().remove<SoftBodyComponent>(m_currentEntity);
        }
    }
}

void ObjectPropertiesWidget::onSoftBodyPropertyChanged()
{
    if (m_isUpdatingUI) return;
    updateSoftBodyComponent();
}

void ObjectPropertiesWidget::onMaterialSelectionChanged()
{
    // Logic to load a .KMaterial file and apply it to the entity would go here.
    // For now, this is a placeholder.
    qDebug() << "Material selection changed (not yet implemented).";
}

void ObjectPropertiesWidget::onPhysicalPropertiesChanged()
{
    if (m_isUpdatingUI) return;
    updateMaterialComponent();
    updateDerivedMechanicalProperties();
}

void ObjectPropertiesWidget::onAppearancePropertiesChanged()
{
    if (m_isUpdatingUI) return;
    updateMaterialComponent();
}

void ObjectPropertiesWidget::onAlbedoColorPickerClicked()
{
    if (m_isUpdatingUI) return;
    QColor newColor = QColorDialog::getColor(Qt::white, this, "Select Albedo Color");
    if (newColor.isValid()) {
        glm::vec3 color = { newColor.redF(), newColor.greenF(), newColor.blueF() };
        setUIColor(color, ui->albedoColorPreviewFrame, ui->albedoRInputDSBox, ui->albedoGInputDSBox, ui->albedoBInputDSBox);
        onAppearancePropertiesChanged(); // Trigger update
    }
}

void ObjectPropertiesWidget::onEmissiveColorPickerClicked()
{
    if (m_isUpdatingUI) return;
    QColor newColor = QColorDialog::getColor(Qt::black, this, "Select Emissive Color");
    if (newColor.isValid()) {
        glm::vec3 color = { newColor.redF(), newColor.greenF(), newColor.blueF() };
        setUIColor(color, ui->emissiveColorPreviewFrame, ui->emissiveRInputDSBox, ui->emissiveGInputDSBox, ui->emissiveBInputDSBox);
        onAppearancePropertiesChanged(); // Trigger update
    }
}

void ObjectPropertiesWidget::onDisplacementTypeChanged(int index)
{
    if (m_isUpdatingUI) return;
    if (!m_scene->getRegistry().valid(m_currentEntity)) return;

    auto& registry = m_scene->getRegistry();
    // 0 = POM, 1 = Tessellation, 2 = None
    ui->POMStepInputDSBox->setEnabled(index == 0);

    registry.remove<ParallaxMaterialTag>(m_currentEntity);
    registry.remove<TessellatedMaterialTag>(m_currentEntity);

    if (index == 0) {
        registry.emplace<ParallaxMaterialTag>(m_currentEntity);
    }
    else if (index == 1) {
        registry.emplace<TessellatedMaterialTag>(m_currentEntity);
    }
    updateMaterialComponent();
}


// --- UI Population and Update Logic ---

void ObjectPropertiesWidget::populateAllTabs()
{
    const QSignalBlocker blocker(this);
    m_isUpdatingUI = true;

    bool isValid = m_scene->getRegistry().valid(m_currentEntity);
    this->setEnabled(isValid);

    if (isValid) {
        populateObjectTab();
        populatePhysicsTab();
        populateMaterialTab();
    }
    else {
        // Clear all fields if no entity is selected
        ui->objectNameInputField->clear();
        ui->XPositionDoubleSpinBox->setValue(0);
        // ... clear all other inputs ...
    }

    m_isUpdatingUI = false;
}

void ObjectPropertiesWidget::populateObjectTab()
{
    if (auto* tag = m_scene->getRegistry().try_get<TagComponent>(m_currentEntity)) {
        ui->objectNameInputField->setText(QString::fromStdString(tag->tag));
    }
    else {
        ui->objectNameInputField->setText("");
    }

    if (auto* transform = m_scene->getRegistry().try_get<TransformComponent>(m_currentEntity)) {
        updateTransformInputs(*transform);
    }
}

void ObjectPropertiesWidget::populatePhysicsTab()
{
    // Rigid Body
    if (auto* rb = m_scene->getRegistry().try_get<RigidBodyComponent>(m_currentEntity)) {
        ui->bodyTypeInputComboBox->setCurrentIndex(static_cast<int>(rb->bodyType));
        ui->MassInputDSBox->setValue(rb->mass);
        ui->LinearDampingInputDSBox->setValue(rb->linearDamping);
        ui->AngularDampingInputDSBox->setValue(rb->angularDamping);
    }

    // Soft Body
    bool hasSoftBody = m_scene->getRegistry().all_of<SoftBodyComponent>(m_currentEntity);
    ui->SoftBodyPhysicsEnableCheckbox->setChecked(hasSoftBody);
    ui->groupBox_7->setEnabled(hasSoftBody);
    ui->groupBox_11->setEnabled(hasSoftBody);

    if (hasSoftBody) {
        // Populate soft body fields
    }
}

void ObjectPropertiesWidget::populateMaterialTab()
{
    // This is a simplified version. A full implementation would involve
    // loading the material from the entity's MaterialComponent.
    if (auto* mat = m_scene->getRegistry().try_get<MaterialComponent>(m_currentEntity)) {
        // Populate Physical Properties
        ui->YoungsModulusInputDSBox->setValue(0); // Placeholder
        // ... populate other physical properties ...

        updateDerivedMechanicalProperties();

        // Populate Appearance Properties
        populateAppearanceTab(*mat);
    }
}

void ObjectPropertiesWidget::populateAppearanceTab(const MaterialComponent& mat)
{
    // Albedo
    setUIColor(mat.albedoColor, ui->albedoColorPreviewFrame, ui->albedoRInputDSBox, ui->albedoGInputDSBox, ui->albedoBInputDSBox);
    ui->textureTilingUInputDSBox->setValue(mat.albedoTiling.x);
    ui->textureTilingVInputDSBox->setValue(mat.albedoTiling.y);

    // Opacity, Metallic, Roughness, AO, Normal, Height
    ui->opacityStrengthSlider->setValue(mat.opacity * 1000);
    ui->metallicStrengthSlider->setValue(mat.metallic * 1000);
    ui->roughnessStrengthSlider->setValue(mat.roughness * 1000);
    ui->aoStrengthSlider->setValue(mat.ao * 1000);
    ui->normalStrengthSlider->setValue(mat.normalScale * 100);
    ui->heightStrengthSlider->setValue(mat.heightScale * 100);

    // Displacement
    if (m_scene->getRegistry().all_of<ParallaxMaterialTag>(m_currentEntity)) {
        ui->dispalcementTypeComboBox->setCurrentIndex(0);
    }
    else if (m_scene->getRegistry().all_of<TessellatedMaterialTag>(m_currentEntity)) {
        ui->dispalcementTypeComboBox->setCurrentIndex(1);
    }
    else {
        ui->dispalcementTypeComboBox->setCurrentIndex(2);
    }
    ui->POMStepInputDSBox->setValue(mat.parallaxSteps);

    // Emissive
    setUIColor(mat.emissiveColor, ui->emissiveColorPreviewFrame, ui->emissiveRInputDSBox, ui->emissiveGInputDSBox, ui->emissiveBInputDSBox);
    ui->emissiveStrengthSlider->setValue(mat.emissiveStrength * 100);
}

void ObjectPropertiesWidget::updateDerivedMechanicalProperties()
{
    // Read inputs, calculate derived values, and set read-only labels.
    // This is a placeholder for the actual physics calculations.
    ui->ShearModulusLabel->setText("N/A");
    ui->BulkModulusLabel->setText("N/A");
    ui->ResilienceModLabel->setText("N/A");
    ui->LameParamLabel->setText("N/A");
}

void ObjectPropertiesWidget::updateTransformInputs(const TransformComponent& transform)
{
    ui->XPositionDoubleSpinBox->setValue(transform.translation.x);
    ui->YPositionDoubleSpinBox->setValue(transform.translation.y);
    ui->ZPositionDoubleSpinBox->setValue(transform.translation.z);

    glm::vec3 eulerDegrees = glm::degrees(glm::eulerAngles(transform.rotation));
    ui->PitchdoubleSpinBox->setValue(eulerDegrees.x);
    ui->YawdoubleSpinBox->setValue(eulerDegrees.y);
    ui->RolldoubleSpinBox->setValue(eulerDegrees.z);

    ui->QuatWdoubleSpinBox->setValue(transform.rotation.w);
    ui->QuatXdoubleSpinBox->setValue(transform.rotation.x);
    ui->QuatYdoubleSpinBox->setValue(transform.rotation.y);
    ui->QuatZdoubleSpinBox->setValue(transform.rotation.z);

    ui->XScaleDoubleSpinBox->setValue(transform.scale.x);
    ui->YScaleDoubleSpinBox->setValue(transform.scale.y);
    ui->ZScaleDoubleSpinBox->setValue(transform.scale.z);
}


void ObjectPropertiesWidget::updateTransformComponent()
{
    if (!m_scene->getRegistry().valid(m_currentEntity)) return;
    auto& transform = m_scene->getRegistry().get<TransformComponent>(m_currentEntity);

    transform.translation = {
        ui->XPositionDoubleSpinBox->value(),
        ui->YPositionDoubleSpinBox->value(),
        ui->ZPositionDoubleSpinBox->value()
    };

    if (ui->rotationTypeSelectionSpinBox->currentIndex() == 0) { // Euler
        glm::vec3 eulerDegrees(ui->PitchdoubleSpinBox->value(), ui->YawdoubleSpinBox->value(), ui->RolldoubleSpinBox->value());
        transform.rotation = glm::quat(glm::radians(eulerDegrees));
    }
    else { // Quaternion
        transform.rotation = glm::normalize(glm::quat(
            ui->QuatWdoubleSpinBox->value(),
            ui->QuatXdoubleSpinBox->value(),
            ui->QuatYdoubleSpinBox->value(),
            ui->QuatZdoubleSpinBox->value()
        ));
    }

    transform.scale = {
        ui->XScaleDoubleSpinBox->value(),
        ui->YScaleDoubleSpinBox->value(),
        ui->ZScaleDoubleSpinBox->value()
    };
}

void ObjectPropertiesWidget::updateRigidBodyComponent()
{
    if (!m_scene->getRegistry().valid(m_currentEntity)) return;
    auto& rb = m_scene->getRegistry().get_or_emplace<RigidBodyComponent>(m_currentEntity);

    rb.bodyType = static_cast<RigidBodyComponent::BodyType>(ui->bodyTypeInputComboBox->currentIndex());
    rb.mass = ui->MassInputDSBox->value();
    // Add logic to link mass and density here
    rb.linearDamping = ui->LinearDampingInputDSBox->value();
    rb.angularDamping = ui->AngularDampingInputDSBox->value();
}

void ObjectPropertiesWidget::updateSoftBodyComponent()
{
    if (!m_scene->getRegistry().valid(m_currentEntity)) return;
    if (!m_scene->getRegistry().all_of<SoftBodyComponent>(m_currentEntity)) return;

    // auto& sb = m_scene->getRegistry().get<SoftBodyComponent>(m_currentEntity);
    // Update soft body properties here
}

void ObjectPropertiesWidget::updateMaterialComponent()
{
    if (!m_scene->getRegistry().valid(m_currentEntity)) return;
    auto& mat = m_scene->getRegistry().get_or_emplace<MaterialComponent>(m_currentEntity);

    // Update all material properties from the UI
    mat.albedoColor.r = ui->albedoRInputDSBox->value() / 255.0f;
    mat.albedoColor.g = ui->albedoGInputDSBox->value() / 255.0f;
    mat.albedoColor.b = ui->albedoBInputDSBox->value() / 255.0f;

    mat.albedoTiling.x = ui->textureTilingUInputDSBox->value();
    mat.albedoTiling.y = ui->textureTilingVInputDSBox->value();

    mat.opacity = ui->opacityStrengthSlider->value() / 1000.0f;
    mat.metallic = ui->metallicStrengthSlider->value() / 1000.0f;
    mat.roughness = ui->roughnessStrengthSlider->value() / 1000.0f;
    mat.ao = ui->aoStrengthSlider->value() / 1000.0f;
    mat.normalScale = ui->normalStrengthSlider->value() / 100.0f;
    mat.heightScale = ui->heightStrengthSlider->value() / 100.0f;

    mat.parallaxSteps = ui->POMStepInputDSBox->value();

    mat.emissiveColor.r = ui->emissiveRInputDSBox->value() / 255.0f;
    mat.emissiveColor.g = ui->emissiveGInputDSBox->value() / 255.0f;
    mat.emissiveColor.b = ui->emissiveBInputDSBox->value() / 255.0f;
    mat.emissiveStrength = ui->emissiveStrengthSlider->value() / 100.0f;
}

void ObjectPropertiesWidget::setUIColor(const glm::vec3& color, QFrame* frame, QSpinBox* r, QSpinBox* g, QSpinBox* b)
{
    QColor qColor;
    qColor.setRgbF(color.r, color.g, color.b);
    frame->setStyleSheet(QString("background-color: %1;").arg(qColor.name()));
    r->setValue(qColor.red());
    g->setValue(qColor.green());
    b->setValue(qColor.blue());
}
